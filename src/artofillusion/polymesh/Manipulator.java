package artofillusion.polymesh;

import java.awt.Rectangle;

import artofillusion.Camera;
import artofillusion.MeshViewer;
import artofillusion.ViewerCanvas;
import artofillusion.math.BoundingBox;
import artofillusion.math.Mat4;
import artofillusion.math.Vec3;
import artofillusion.ui.MeshEditController;
import buoy.event.EventSource;
import buoy.event.KeyPressedEvent;
import buoy.event.WidgetMouseEvent;

/**
 * This is the base class for Manipulators.
 */
public abstract class Manipulator extends EventSource
{
    protected AdvancedEditingTool tool;
    protected Rectangle bounds, originalBounds;
    protected AdvancedEditingTool.SelectionProperties selectionBounds;
    protected int MARGIN = 50;
    protected PolyMeshValueWidget valueWidget;
    protected ViewerCanvas view;
    protected boolean active;
    protected static boolean helpModeOn;

    /**
     * Creates a Manipulator with an existing value widget assoicated to it
     * @param tool The tool responsible for the manipulator
     * @param view  The view in which the manipulators are displayed
     * @param valueWidget The value widget the manipualtors should use
     */
    public Manipulator(AdvancedEditingTool tool, ViewerCanvas view, PolyMeshValueWidget valueWidget)
    {
        this.tool = tool;
        this.valueWidget = valueWidget;
        this.view = view;
        active = true;
    }

    /**
     * Creates a Manipulator associetd to a view
     * @param tool The tool responsible for the manipulator
     * @param view  The view in which the manipulators are displayed
     */
    public Manipulator(AdvancedEditingTool tool, ViewerCanvas view)
    {
        this(tool, view, null);
    }

    /**
     * Sets the manipulator bounds on screen, for example after user sets a new selection.
     * Some manipulators rely on bounds being non null to show up.
     *
     * @param bounds The new manipulator bounds (2D)
     */
    public void setBounds(Rectangle bounds)
    {

        this.originalBounds = bounds;
        if (bounds == null)
            this.bounds = null;
        else
        {
            this.bounds = new Rectangle(bounds);
            this.bounds.x -= MARGIN;
            this.bounds.y -= MARGIN;
            this.bounds.width += 2*MARGIN;
            this.bounds.height += 2*MARGIN;
        }
    }

    /**
     * Returns the manipulator bounds, as previously calculated after a call to setBounds().
     * This bounds are inset by an amount of MARGIN.
     *
     * @return The manipulator bounds
     */
    public Rectangle getBounds()
    {
        return bounds;
    }

    /**
     * Returns the original rectangle bounds, as previously set by a call to setBounds().
     *
     * @return The manipulator bounds
     */
    public Rectangle getOriginalBounds()
    {
        return originalBounds;
    }

    /**
     * Returns true if the manipulator is active
     * @return Manipulator status
     */
    public boolean isActive()
    {
        return active;
    }

    /**
     * Sets the activate/inactive status of the manipulator. Inactive manipulators don't
     * show up on the views until activated again.
     *
     * @param active
     */
    public void setActive(boolean active)
    {
        this.active = active;
    }

    /**
     * Draws the manipulator widgets
     *
     */
    public abstract void draw();

    /**
         * Call this method if a mouse moved event is generated by a view
         *
         * @param e  The mouse event
         * @return True if the manipulator is concerned by this event
         */
        public boolean mouseMoved(WidgetMouseEvent e)
        {
            return false;
        }


    /**
     * Call this method if a mouse pressed event is generated by a view
     *
     * @param e  The mouse event
     * @return True if the manipulator is concerned by this event
     */
    public boolean mousePressed(WidgetMouseEvent e)
    {
        return false;
    }

    /**
     * Call this method if a mouse pressed event is generated by a view
     *
     * @param e  The mouse event
     * @return True if the manipulator is concerned by this event
     */
    public boolean mouseClicked(WidgetMouseEvent e)
    {
        return false;
    }

    /**
     * Call this method if a mouse dragged event is generated by a view
     *
     * @param e  The mouse event
     * @return True if the manipulator is concerned by this event
     */
    public boolean mouseDragged(WidgetMouseEvent e)
    {
        return false;
    }

    /**
     * Call this method if a mouse released event is generated by a view
     *
     * @param e  The mouse event
     * @return True if the manipulator is concerned by this event
     */
    public boolean mouseReleased(WidgetMouseEvent e)
    {
        return false;
    }

    /**
     * Call this method if the mouse has been clicked on a handle
     *
     * @param e  The mouse event
     * @param handle The handle the mouse has been clicked on
     * @param pos The position of the handle
     * @return True if the manipulator is concerned by this event
     */
    public boolean mousePressedOnHandle(WidgetMouseEvent e, int handle, Vec3 pos)
    {
        return false;
    }

    /**
     *  Call this method if a key has been pressed
     *
     * @param e The key pressed event
     * @return True if the key event has been handled byb the manipulator
     */
    public boolean keyPressed(KeyPressedEvent e)
    {
        return false;
    }

    /**
     * tells the manipualtor to change the view mode if it features
     * several view modes (e.g. 3D manipulator)
     */
    public void toggleViewMode()
    {
    }

    /**
     * Sets the perspective view for the manipulator
     * @param perspective True if the view is a perspective view
     */
    public void setPerspective(boolean perspective)
    {
    }

    /**
     * Returns the value widget associated to the manipulator, if any
     * @return The value widget associated to the manipulator
     */
    public PolyMeshValueWidget getValueWidget()
    {
        return valueWidget;
    }

    /**
     * Sets the value widget to use in conjunction with the manipulator
     * @param valueWidget
     */
    public void setValueWidget(PolyMeshValueWidget valueWidget)
    {
        this.valueWidget = valueWidget;
    }

    /**
     *  Given a bounding box in view coordinates, find the corresponding rectangle in
     *  screen coordinates.
     */
    Rectangle findScreenBounds(BoundingBox b, Camera cam, MeshViewer view, MeshEditController controller)
    {
        Mat4 m = cam.getObjectToWorld();
        Rectangle r;

        if (b == null)
            return null;
        cam.setObjectTransform(cam.getViewToWorld());
        r = cam.findScreenBounds(b);
        cam.setObjectTransform(m);
        if (r != null)
            r.setBounds(r.x, r.y, r.width, r.height);
        return r;
    }

    public static void toggleHelpMode()
    {
        helpModeOn = !helpModeOn;
    }

    public static boolean isHelpModeOn()
    {
        return helpModeOn;
    }

    public static void setHelpModeOn(boolean helpModeOn)
    {
        Manipulator.helpModeOn = helpModeOn;
    }

    /* utility methods */


    /**
     * Base class for manipulator events
     */
    public static class ManipulatorEvent
    {
        private Manipulator source;
        private ViewerCanvas view;

        public ManipulatorEvent(Manipulator manipulator, short type, ViewerCanvas view)
        {
            source = manipulator;
            this.view = view;
        }

        public ManipulatorEvent(Manipulator manipulator, ViewerCanvas view)
        {
            this(manipulator, (short)-1, view);
        }

        public Manipulator getSource()
        {
            return source;
        }

        public ViewerCanvas getView()
        {
            return view;
        }
    }

    public static class ManipulatorPrepareChangingEvent extends ManipulatorEvent
    {
        public ManipulatorPrepareChangingEvent(Manipulator manipulator, ViewerCanvas view)
        {
            super(manipulator, view);
        }
    }
    public static class ManipulatorAbortChangingEvent extends ManipulatorEvent
    {
        public ManipulatorAbortChangingEvent(Manipulator manipulator, ViewerCanvas view)
        {
            super(manipulator, view);
        }
    }

    public static class ManipulatorCompletedEvent extends ManipulatorEvent
    {
        public ManipulatorCompletedEvent(Manipulator manipulator, ViewerCanvas view)
        {
            super(manipulator, view);
        }
    }
}
